"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.pluginOptionsSchema = exports.onPostBuild = exports.onCreateWebpackConfig = void 0;

var _fs = require("fs");

var _path = require("path");

var _gatsbyCoreUtils = require("gatsby-core-utils");

var _webpackAssetsManifest = _interopRequireDefault(require("webpack-assets-manifest"));

var _buildHeadersProgram = _interopRequireDefault(require("./build-headers-program"));

var _constants = require("./constants");

var _createRedirects = _interopRequireDefault(require("./create-redirects"));

var _pluginData = _interopRequireDefault(require("./plugin-data"));

// https://www.netlify.com/docs/headers-and-basic-auth/
const assetsManifest = {};
/** @type {import("gatsby").GatsbyNode["pluginOptionsSchema"]} */

const pluginOptionsSchema = ({
  Joi
}) => {
  const MATCH_ALL_KEYS = /^/; // headers is a specific type used by Netlify: https://www.gatsbyjs.com/plugins/gatsby-plugin-netlify/#headers

  const headersSchema = Joi.object().pattern(MATCH_ALL_KEYS, Joi.array().items(Joi.string())).description(`Add more Netlify headers to specific pages`);
  return Joi.object({
    headers: headersSchema,
    allPageHeaders: Joi.array().items(Joi.string()).description(`Add more headers to all the pages`),
    mergeSecurityHeaders: Joi.boolean().description(`When set to false, turns off the default security headers`),
    mergeLinkHeaders: Joi.boolean().description(`When set to false, turns off the default gatsby js headers`),
    mergeCachingHeaders: Joi.boolean().description(`When set to false, turns off the default caching headers`),
    transformHeaders: Joi.function().maxArity(2).description(`Transform function for manipulating headers under each path (e.g.sorting), etc. This should return an object of type: { key: Array<string> }`),
    generateMatchPathRewrites: Joi.boolean().description(`When set to false, turns off automatic creation of redirect rules for client only paths`)
  });
}; // Inject a webpack plugin to get the file manifests so we can translate all link headers

/** @type {import("gatsby").GatsbyNode["onCreateWebpackConfig"]} */


exports.pluginOptionsSchema = pluginOptionsSchema;

const onCreateWebpackConfig = ({
  actions,
  stage
}) => {
  if (stage !== _constants.BUILD_HTML_STAGE && stage !== _constants.BUILD_CSS_STAGE) {
    return;
  }

  actions.setWebpackConfig({
    plugins: [new _webpackAssetsManifest.default({
      // mutates object with entries
      assets: assetsManifest,
      merge: true
    })]
  });
};
/** @type {import("gatsby").GatsbyNode["onPostBuild"]} */


exports.onCreateWebpackConfig = onCreateWebpackConfig;

const onPostBuild = async ({
  store,
  pathPrefix,
  reporter
}, userPluginOptions) => {
  const pluginData = (0, _pluginData.default)(store, assetsManifest, pathPrefix);
  const pluginOptions = { ..._constants.DEFAULT_OPTIONS,
    ...userPluginOptions
  };
  const {
    redirects,
    pages,
    functions = [],
    program
  } = store.getState();

  if (pages.size > _constants.PAGE_COUNT_WARN && (pluginOptions.mergeCachingHeaders || pluginOptions.mergeLinkHeaders)) {
    reporter.warn(`[gatsby-plugin-netlify] Your site has ${pages.size} pages, which means that the generated headers file could become very large. Consider disabling "mergeCachingHeaders" and "mergeLinkHeaders" in your plugin config`);
  }

  reporter.info(`[gatsby-plugin-netlify] Creating SSR redirects...`);
  let count = 0;
  const rewrites = [];
  let needsFunctions = functions.length !== 0;
  [...pages.values()].forEach(page => {
    const {
      mode,
      matchPath,
      path
    } = page;

    if (mode === 'SSR' || mode === 'DSG') {
      needsFunctions = true;
    }

    if (mode === `SSR`) {
      const fromPath = matchPath !== null && matchPath !== void 0 ? matchPath : path;
      count++;
      rewrites.push({
        fromPath,
        toPath: `/.netlify/functions/__ssr`
      }, {
        fromPath: (0, _gatsbyCoreUtils.generatePageDataPath)(`/`, fromPath),
        toPath: `/.netlify/functions/__ssr`
      });
    }

    if (pluginOptions.generateMatchPathRewrites && matchPath && matchPath !== path) {
      rewrites.push({
        fromPath: matchPath,
        toPath: path
      });
    }
  });
  reporter.info(`[gatsby-plugin-netlify] Created ${count} SSR redirect${count === 1 ? `` : `s`}...`);

  if (!needsFunctions) {
    reporter.info(`[gatsby-plugin-netlify] No Netlify functions needed. Skipping...`);
    await _fs.promises.writeFile((0, _path.join)(program.directory, `.cache`, `.nf-skip-gatsby-functions`), '');
  }

  await Promise.all([(0, _buildHeadersProgram.default)(pluginData, pluginOptions, reporter), (0, _createRedirects.default)(pluginData, redirects, rewrites)]);
};

exports.onPostBuild = onPostBuild;